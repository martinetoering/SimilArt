<!-- base.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>{% block title %}{% endblock %}</title>

    <!-- Bootstrap core CSS -->
    <link href="https://getbootstrap.com/docs/4.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- D3 package -->
    <script src="https://d3js.org/d3.v4.min.js"></script>

    <!-- Layout stylesheet -->
<!--   <link rel="stylesheet" type="text/css" href="base.css">-->
<!-- For shuffle/undo/redo button icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <style>
        p, .txt {  text-align: justify;
            text-justify: inter-word;
        }

        body {
			margin: 0;
			position: fixed;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
			background-color: #216869;
		}

        .image-outline {
            fill: none;
            stroke: #dce1de;
            stroke-width: 2;
        }
        .middle {
            fill: #9cc5a1;
            stroke: #1f2421;
            stroke-width: 4;

        }
        .button {
            fill: #49a078;
            stroke: #1f2421;
            stroke-width: 2;
        }

        .text {
            color: #491217;
            font-weight: bold;
            stroke-width: 0;
            font-size: 0.5em;
            /*font-family: sans-serif;*/
            text-anchor: start;
        }

        #container{
            width: 100%
        }
        #tooltip {	
		    position: relative;			
		    text-align: center;			
		    width: 120px;										
		    padding: 2px;				
		    font: 8px sans-serif;		
		    text-align: center;
		    background: lightsteelblue;	
		    border: 0px;		
		    border-radius: 8px;			
		    pointer-events: none;			
		}

    </style>
</head>
<body>
<div id="container"></div>
</body>
<script type="text/javascript">
    var svgwidth = 960;
    var svgheight = 500;
</script>
<!-- Import dragable images code -->
<script src="../static/js/drag_imgs.js"></script>
<!-- Import set_center image function -->
<script src="../static/js/center_image.js"></script>
<!-- Import non dragable images code-->
<script src="../static/js/append_imgs.js"></script>
<!-- Imports for the backend connection + nearest neighbor querying -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.min.js"></script>
<script src="../static/js/nearest_neighbors.js"></script>

<script type="text/javascript">
    var svg = d3.select("#container").append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 " + svgwidth + " " + svgheight);

    var image = {
        size: 50
    }

    var undo_stack = [];
    var redo_stack = [];
    var old_middle_image = "";
    var selected_locs_dict = {};
    var imgs_path = "static/subset/";
    var defs = svg.append("defs");
    var middle_x = svgwidth*0.25;
    var middle_y = svgheight*0.25;
    var middle_width = svgwidth*0.5;
    var middle_height = svgwidth*0.25;
    var middle = svg.append("svg")
        .attr("class", "middle")
        .attr("x", middle_x)
        .attr("y", middle_y)
        .attr("width", middle_width)
        .attr("height", middle_height);

    middle.append("rect")
        .attr("class", "middle")
        .attr("width", svgwidth*0.5)
        .attr("height", svgwidth*0.25);

    var center = middle.append("svg")
        .append("image")
        .attr("clip-path", "url(#clip)");

    // tooltip
    var tooltip = d3.select("body")
        .append("div")
        .attr("id", "tooltip")
        .style("position", "absolute")
        .style("z-index", "10")
        .style('color', 'white')
        .style("visibility", "hidden")
        .style('font-size', '12px');

    // buttons
    var actionbuttons_size = svgwidth*0.020;
    var undo_button = middle
        .append("rect")
            .attr("class", "button")
            .attr("width", actionbuttons_size)
            .attr("height", actionbuttons_size);

    var undoText = middle.append("image")
		.attr("href", imgs_path + 'undo.png')
		.attr("height", actionbuttons_size)
		.attr("width", actionbuttons_size)
		.attr("clip-path", "url(#clip)");
        // .attr('fill', 'white');


    var redo_button = middle
        .append("rect")
            .attr("class", "button")
            .attr("x", svgwidth*0.020)
            .attr("width", actionbuttons_size)
            .attr("height", actionbuttons_size);

    var redoText = middle.append("image")
		.attr("href", imgs_path + 'redo.png')
		.attr("height", actionbuttons_size)
        .attr("width", actionbuttons_size)
        .attr("x", svgwidth*0.020)
		.attr("clip-path", "url(#clip)");
        // .attr('fill', 'white');

    undo_button.on('click', function() {
        console.log('go back to previous image');
        undo();
    });
    redo_button.on('click', function() {
        console.log('redo images');
        redo()
    });
    var randomizebutton_width = 50;
    var randomizebutton_height = 30;
    var randomizebutton = svg.append("g")
        .datum({position: [0, 0], height: 35, width: 55})
        .attr("transform", d => "translate(" + d.position + ")");

    randomizebutton.append("rect")
        .attr("class", "button")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", randomizebutton_width)
        .attr("height", randomizebutton_height);

    randomizebutton.append("image")
		.attr("href", imgs_path + 'shuffle.png')
		.attr("height", randomizebutton_height)
		.attr("width", randomizebutton_width)
		.attr("clip-path", "url(#clip)");
        // .attr('fill', 'white');

    randomizebutton.on('click', function() {
        // randomize all outside images
        change_dissimilar_images()
    });

    // Listener for if the json has been created
    socket.on('json_loaded', function () {
        console.log("JSON CREATED");
        get_meta();
    })

    // This can be used to execute code once a flag become true
    function TrueListener(callback, init_val=false) {
        this.value = init_val;
        this.onTrue = callback;
        // Check if starting with true
        if (init_val == true) {
            this.onTrue();
        }
        // value getter
        this.get = function() {
            return this.value;
        }
        // value setter
        this.set = function(v) {
            if (v == true) {
                this.onTrue();
            }
        }
    }

    
    var initial_img = 2005927;
    var middle_image = initial_img;
    var nr_similar_images = 10;
    var nr_dissimilar_images = 10;
    var outside_images = [];
    var outside_subset = [];
    var dissimilar_locs = [];
    var similar_locs = [];
    var temp_similar_locs = [];

    set_center(center, middle_image);
    const sleep = (milliseconds) => {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    function get_meta(listener) {
        fetch("static/subset_meta.json").then(response => {
            if (response.ok) {
                console.log("Loading json from disk");
                return response.json();
            } else {
                console.log("JSON file missing");
                console.log("Sending request to create json");
                socket.emit('create_meta_json');
            }
        })
        .then(json => {
            if (json) {
                data = json;
                available_ids = Object.keys(data);
                console.log("Data loaded");
                listener.set(true);
            }
        });
    }

    // create grid for possible locations of images
    var i;
    var j;
    var grid_similar = [];
    var grid_dissimilar = [];

    for (i = 0; i < svgwidth - image.size; i += image.size) {
        for (j = 0; j < svgheight - image.size; j += image.size) {

            // skip middle section and randomize button
            if ((i + image.size > middle_x && i < (middle_x + middle_width)) &&
                    (j + image.size > middle_y && j < (middle_y + middle_height)) ||
                    (i < randomizebutton_width && j < randomizebutton_height))

                continue;

            grid_dissimilar.push([i, j]);
        }
    }

    for (i = middle_x; i < middle_x + middle_width - image.size; i += image.size) {
        for (j = middle_y; j < middle_y + middle_height - image.size; j += image.size) {

            // skip action buttons and center image
            if ((i < middle_x + actionbuttons_size && j < middle_y + actionbuttons_size) ||
                    (i + image.size > middle_x + center_image_x &&
                     i < middle_x + center_image_x + center_image_size &&
                     j + image.size > middle_y + center_image_y &&
                     j < middle_y + center_image_y + center_image_size))

                continue;

            grid_similar.push([i, j]);
        }
    }

    // ---------------- Helper Functions ------------------
    function change_dissimilar_images() {
        images_ids = available_ids.filter(n => !nearest_ids.includes(n));
        images_ids = images_ids.sort(() => Math.random() - 0.5);
        images_ids_subset = images_ids.slice(0, nr_dissimilar_images);
        grid_dissimilar = grid_dissimilar.sort(() => Math.random() - 0.5);
        dissimilar_locs = grid_dissimilar.slice(0, nr_dissimilar_images);
        // dissimilar_locs = [[30, 400], [810, 280], [650, 390], [50, 80], [400, 30]];

        // Remove all current images
        d3.selectAll("g#outside_image")
            .transition()
            .duration(2000)
            .style("opacity", 0)
            .remove();

        // --- selecting location of dis-similar layer and plotting those images:
        var i;
        for (i = 0; i < images_ids_subset.length; i++) {
            meta_data_painting = data[images_ids_subset[i]]
            artwork_name = meta_data_painting['artwork_name']
            artist_full_name = meta_data_painting['artist_full_name']
            appendDraggableImage(imgs_path + images_ids_subset[i].toString() + ".jpg", dissimilar_locs[i], artwork_name, artist_full_name)
        };

        // d3.selectAll("g#outside_image")
        //     .style('opacity', 0)
        //     .transition()
        //     .duration(4000)
        //     .style("opacity", 1);

        console.log("change dissimilar");
    }

    function handle_stacks(){
        /*
        After clicking on a image central image changes. Here we add the current image before updating the central image.
        So we will be able to retrieve this state after pushing the update button.
         */
        undo_stack.push(middle_image);
    }


    function change_similar_images() {
        /*
        Here we find the "n" similar images to the central image, using KNN method.
        We also define the coordinates for each of those similar images.
        */
        nearest_neighbors(middle_image, nr_similar_images);

        // if central image has been seen before use the precomputed locations for similar images otherwise calculate their positions:
        if (selected_locs_dict[middle_image.toString()] == undefined){
            grid_similar = grid_similar.sort(() => Math.random() - 0.5);
            temp_similar_locs = grid_similar.slice(0, nr_similar_images);
            selected_locs_dict[middle_image.toString()] = temp_similar_locs;
        }
        else {
            temp_similar_locs = selected_locs_dict[middle_image.toString()];
        }
        similar_locs = temp_similar_locs;

        // Remove all current images
        d3.selectAll("g#middle_image")
            .transition()
            .duration(2000)
            .style("opacity", 0)
            .remove()

        // Sleep for 500 ms until neighbouring images is found
        sleep(500).then(() => {
            // --- selecting location of similar layer and plotting those images:
            // Start i from 1 to filter-out central image:
            var i;
            for (i = 1; i < nearest_ids.length; i++) {
                meta_data_painting = data[nearest_ids[i]]
                artwork_name = meta_data_painting['artwork_name']
                artist_full_name = meta_data_painting['artist_full_name']
                appendImage(imgs_path + nearest_ids[i].toString() + ".jpg",
                    similar_locs[i-1], artwork_name, artist_full_name);
            };

            console.log("change similar");

        });

    }

    function redo() {
        if (redo_stack.length === 0)
            return;
        undo_stack.push(middle_image);

        // remove current image from undo stack:
        middle_image = redo_stack.pop();
        set_center(center, middle_image);
        change_similar_images();
    }

    function undo() {
        if (undo_stack.length === 0)
            return;
        redo_stack.push(middle_image);

        // remove current image from undo stack:
        middle_image = undo_stack.pop();
        set_center(center, middle_image);
        change_similar_images();

    }

    // ----------------------------------------------------------------------------


    // Data loading from json
    var data;
    var available_ids;

    DATA_LOADED = new TrueListener(function() {
        change_similar_images();
        change_dissimilar_images();
        handle_stacks();
    })

    get_meta(DATA_LOADED);



</script>
</html>
